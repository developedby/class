// type PairBool
// Contains 2 Booleans inside it
type PairBool { 
  new(fst: Bool, snd: Bool)
}

// Returns the first element of a pair
fst(pair: PairBool): Bool
  case pair {
    new: pair.fst
  }

// Returns the second element of a pair
snd(pair: PairBool): Bool
  open pair
  pair.snd

// Returns true if both elements of a PairBool are identical
eql_elements(a: PairBool): Bool 
  open a
  Bool.eql(a)
  
// Returns true if both Pairs are equal 
// eql(PairBool.new(false, false), PairBool.new(true, true)) -> false 
// eql(PairBool.new(true, false), PairBool.new(true, false)) -> true
eql(a: PairBool, b: PairBool): Bool
  open a
  open b
  let bool_eql = (x:Bool y:Bool)
    case x y {
      false false: true
      true  true: true
    }
  bool_eql(a.fst b.fst) && (a.snd b.snd)

// Returns true if both Pairs are different
// eql(PairBool.new(false, false), PairBool.new(true, true)) -> true 
// eql(PairBool.new(true, false), PairBool.new(true, false)) -> false
xor(a: PairBool, b: PairBool): Bool
  Bool.not(eql(a, b))
  
// Creates a PairBool from 2 Booleans
create(a: Bool, b: Bool): PairBool
  PairBool.new(a b)

// Inverts the values of a PairBool
// neg(PairBool.new(false, false) -> PairBool.new(true, true)
// neg(PairBool.new(false, true) -> PairBool.new(true, false)
neg(pair: PairBool): PairBool
  open pair
  PairBool.new(Bool.not(pair.fst), Bool.not(pair.snd))

// Inverts the 2 elements of a PairBool
swap(pair: PairBool): PairBool 
  open pair
  PairBool.new(pair.snd pair.fst)
